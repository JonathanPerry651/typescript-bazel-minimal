load("@rules_proto_grpc_js//:defs.bzl", "js_grpc_web_library")
load("@aspect_rules_ts//ts:defs.bzl", "ts_project")

def _generate_index_ts_impl(ctx):
    proto_files = []
    for dep in ctx.attr.deps:
        if ProtoInfo in dep:
            proto_files.extend(dep[ProtoInfo].direct_sources)
            
    pb_target_name = ctx.attr.pb_target_name
    output_file = ctx.actions.declare_file(ctx.attr.output_name + "/index.ts")
    
    # Create a manifest file mapping source path to export base path
    # Create args object with param file support
    args = ctx.actions.args()
    args.set_param_file_format("multiline")
    args.use_param_file("%s", use_always = True)
    
    for f in proto_files:
        path = f.short_path
        
        # Normalize path if external
        if path.startswith("../"):
            parts = path.split("/")
            path = "/".join(parts[2:])
        
        if path.endswith(".proto"):
            base_path = path[:-6]
        else:
            base_path = path

        # Construct export base path (e.g. '../target_pb/base')
        export_base = "../%s_pb/%s" % (pb_target_name, base_path)
        
        # Manifest format: SOURCE_SHORT_PATH EXPORT_BASE
        # We use the artifact directly with format string to allow path mapping
        args.add(f, format = "%s " + export_base)

    # Shell command to generate index.ts
    # $1 is the output file path
    # $2 is the path to the params file generated by Bazel
    command = """
    output="$1"
    params="$2"
    echo "// Generated exports for {name}" > "$output"
    while read -r source export_base; do
        echo "export * from '${{export_base}}_pb';" >> "$output"
        # Check if file defines a service (simple regex)
        # Use simple grep to check for "service ServiceName"
        # Use [[:space:]] for portability in strict bazel environments
        if grep -q "^[[:space:]]*service[[:space:]]" "$source"; then
            echo "export * from '${{export_base}}_grpc_web_pb';" >> "$output"
        fi
    done < "$params"
    """.format(
        name = ctx.attr.name,
    )
    
    ctx.actions.run_shell(
        outputs = [output_file],
        inputs = proto_files,
        arguments = [output_file.path, args],
        command = command,
        mnemonic = "GenerateGrpcWebIndex"
    )
    
    return [DefaultInfo(files = depset([output_file]))]

_generate_index_ts = rule(
    implementation = _generate_index_ts_impl,
    attrs = {
        "deps": attr.label_list(providers = [ProtoInfo]),
        "pb_target_name": attr.string(mandatory = True),
        "output_name": attr.string(mandatory = True),
    },
)

def wrapped_js_grpc_web_library(name, protos, **kwargs):
    """
    Wraps js_grpc_web_library to provide a simplified import experience.

    This macro:
    1. Generates the standard js_grpc_web_library targets (messages and service definitions).
    2. Generates an index.ts file that re-exports all generated symbols.
    3. Wraps everything in a ts_project that exposes the index.ts.

    This allows consumers to import from a single location (the target path) rather than 
    referencing deeply nested generated file paths.

    Args:
        name: The name of the target.
        protos: A list of proto_library targets to generate code for. Source files are inferred from ProtoInfo.
        **kwargs: Additional arguments passed to js_grpc_web_library.

    Example:
        BUILD.bazel:
        ```starlark
        wrapped_js_grpc_web_library(
            name = "calculator_js_grpc_web",
            protos = [":calculator_proto"],
        )
        ```

        Usage in TypeScript:
        ```typescript
        // Import from the generated target path
        import { SumRequest } from 'my_workspace/path/to/package/calculator_js_grpc_web';
        ```
    """
    pb_name = name + "_pb"
    js_grpc_web_library(
        name = pb_name,
        protos = protos,
        **kwargs
    )

    # Use custom rule for index generation
    _generate_index_ts(
        name = name + "_gen_index",
        deps = protos,
        pb_target_name = pb_name,
        output_name = name,
    )

    ts_project(
        name = name,
        srcs = [name + "_gen_index"], # The rule outputs the file
        declaration = True,
        deps = [
            ":" + pb_name,
            "//:node_modules/@types/google-protobuf",
            "//:node_modules/grpc-web",
            "//:node_modules/google-protobuf",
        ],
        tsconfig = "//:tsconfig_build",
        transpiler = "tsc",
        source_map = True,
        visibility = ["//visibility:public"],
    )
